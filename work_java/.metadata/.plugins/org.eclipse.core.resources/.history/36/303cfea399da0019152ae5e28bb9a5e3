package argorithm3;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Dijkstra {
	static int N, K;

	public static void main(String[] args) throws IOException {
		// 거리 배열을 준비
		// 시작점을 고르고 시작점으로부터 갈 수 있는 각 정점에서는 거리를 적고 못가는 곳은 큰 값 적어줌
		// 시작점에 대해 방문체크
		// 방문 체크가 안된 정점 중 현재까지 가장 작은 정점 찾기
		// 찾은 정점으로부터 갈 수 있는 정점들에 대해서 기존 알고 있던 거리보다 더 짧으면 갱신
		// 시작점에서 찾은 정점까지의 거리 + 찾은 정점에서 다른 정점까지 거리
		String input = "6 11\n0 1 3\n0 2 5\n1 2 2\n1 3 6\n2 1 1\n2 4 6\n2 3 4\n3 4 2\n3 5 3\n4 0 3\n4 5 6\n";
		BufferedReader br = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(input.getBytes())));
		StringTokenizer stk = new StringTokenizer(br.readLine());
		int V = Integer.parseInt(stk.nextToken());
		int E = Integer.parseInt(stk.nextToken());
		int[][] adj = new int[V][V];
		for (int i = 0; i < E; i++) {
			stk = new StringTokenizer(br.readLine());
			adj[Integer.parseInt(stk.nextToken())][Integer.parseInt(stk.nextToken())] = Integer
					.parseInt(stk.nextToken());
		}
		int[] dist = new int[V];
		boolean[] visited = new boolean[V];
		visited[0] = true;
		for (int i = 0; i < V; i++) {
			dist[i] = adj[0][i];
			if (adj[0][i] == 0)
				dist[i] = 999;
		}
		System.out.println(Arrays.toString(dist));
		for (int i = 0; i < V - 1; i++) {
		}
	}

}
