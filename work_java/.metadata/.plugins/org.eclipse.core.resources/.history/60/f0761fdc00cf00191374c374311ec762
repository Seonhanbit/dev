import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 구슬탈출2 {
	public static int N;
	public static int M;
	public static char[][] arr;
	public static char[][] copy_arr;// 아직 선언 안했음.
	public static boolean redcheck[][];
	public static boolean bluecheck[][];
	public static boolean redchk;
	public static boolean bluechk;
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		// 빨간 구슬 1개, 파란 구슬 1개
		// 보드에 탈출구 하나
		// 빨간 구슬을 구멍을 통해서 빼낸다.파란구슬 X
		// 중력을 이용한다. 한쪽 벽끝까지 도달
		// 빨간구슬 움직이는 것과 파란구슬 움직이는 것이 동시에
		// 동시에 빠지면 실패
		// 완전탐색, 10번 기회
		// 벽에 닿았을 때 빨간 구슬과 파란구슬의 좌표가 같을 때
		// 한쪽 끝까지 도달하고 다시 백트래킹해야한다.
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String str = br.readLine();
		StringTokenizer st = new StringTokenizer(str);
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		arr = new char[N][M];
		redcheck = new boolean[N][M];
		bluecheck = new boolean[N][M];
		int red_row = -1;
		int red_col = -1;
		int blue_row = -1;
		int blue_col = -1;
		for (int row = 0; row < N; row++) {
			str = br.readLine();
			for (int col = 0; col < M; col++) {
				arr[row][col] = str.charAt(col);
				if (arr[row][col] == 'R') {
					red_row = row;
					red_row = col;
				} else if (arr[row][col] == 'B') {
					blue_row = row;
					blue_col = col;
				}
			}
		}
		// 4방향 탐색을 시작한다.각각의 빨간구슬이 움직일때 파란 구슬도 같이 움직인다.
		int move=1;
		for (; move <= 10; move++) {
			//blue와 red의 위치를 다시 찾ㄴ는다.
			dfs(red_row, red_col, blue_row, blue_col);
			if(bluechk==true||redchk==true) {
				break;
			}
		}
		if(bluechk)
			System.out.println(-1);
		else if(redchk)
			System.out.println(move-1);
	}

	// 빨간구슬과 파란구슬의 좌표를 입력받는다.
	// 한쪽방향은 벽이 만날때까지 쭉 타고 들어가야한다.
	public static int dx[] = { 0, 0, 1, -1 };
	public static int dy[] = { 1, -1, 0, 0 };

	// 방향 상 하 좌 우 를 주어보자
	//1(상),2(하),3(좌),4(우)
	public static void dfs (int rd_row,int rd_col, int bl_row,int bl_col) {
		
		//종료조건 벽에 도달했을때 만약 빨간구슬이 앞에 있다면과 파란 구슬이 앞에 있다면으로 나누어 준다.
		for(int k=0;k<4;k++) {
			int nr_r=rd_row+dx[k];
			int nr_c=rd_col+dy[k];
			int nb_r=bl_row+dx[k];
			int nb_c=bl_col+dy[k];
			//빨간구슬이 벽인데 파란구슬이 벽이 아니라면 일단 움직인다.
			//조건 빨간구슬이 벽인데 파란구슬이 아닌경우
			//파란구슬이 벽인데 빨간구슬이 아닌경우
			if(arr[nr_r][nr_c]=='#'&&arr[nb_r][nb_c]=='.'&&!bluecheck[nb_r][nb_c]) {
				bluecheck[nb_r][nb_c]=true;
				arr[nb_r][nb_c]='B';
				arr[bl_row][bl_col]='.';
				dfs(rd_row,rd_col,nb_r,nb_c);
			}else if(arr[nr_r][nr_c]=='.'&&arr[nb_r][nb_c]=='#'&&!redcheck[nr_r][nr_c]&&!bluecheck[nb_r][nb_c]) {
				redcheck[nr_r][nr_c]=true;
				arr[nr_r][nr_c]='R';
				arr[rd_row][rd_col]='.';
				dfs(nr_r,nr_c,bl_row,bl_col);
			}else if(arr[nr_r][nr_c]=='.'&&arr[nb_r][nb_c]=='.'&&!redcheck[nr_r][nr_c]&&!bluecheck[nb_r][nb_c]) {
				bluecheck[nb_r][nb_c]=true;
				redcheck[nr_r][nr_c]=true;
				arr[nr_r][nr_c]='R';
				arr[rd_row][rd_col]='.';
				arr[nb_r][nb_c]='B';
				arr[bl_row][bl_col]='.';
				dfs(nr_r,nr_c,nb_r,nb_c);
			}else if(arr[nr_r][nr_c]=='#'&&arr[nb_r][nb_c]=='#'&&!redcheck[nr_r][nr_c]&&!bluecheck[nb_r][nb_c]) {
				return;
			}else if(arr[nr_r][nr_c]=='#'&&arr[nb_r][nb_c]=='R'&&!redcheck[nr_r][nr_c]&&!bluecheck[nb_r][nb_c]) {
				return;
			}
			else if(arr[nr_r][nr_c]=='B'&&arr[nb_r][nb_c]=='#'&&!redcheck[nr_r][nr_c]&&!bluecheck[nb_r][nb_c]) {
				return;
			}
			else if(arr[nr_r][nr_c]=='O') {
				redchk=true;
			}
			else if(arr[nb_r][nb_c]=='O') {
				bluechk=true;
			}
		}
	}
}
